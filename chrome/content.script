/*
CONTENT SCRIPT - gets added to raw pages
Do NOT modify, or change the file extension.
This contains an event listener added directly to a site's DOM.
The execution environment IS the website itself.
This serves as a means of communicating w/ our extension via listeners.
*/
function INJECT_SCRIPT (script) {
  //  https://stackoverflow.com/questions/30197155/wait-for-an-async-callback-to-finish-before-completing-separate-function-in-java
  //  https://stackoverflow.com/questions/8578617/inject-a-script-tag-with-remote-src-and-wait-for-it-to-execute
  /*
  Proposed flow:
  - Add an event listener awaiting a script value
  - Inject said script
    - Include an event that returns said value
    - on value, return the data
  */
  function inject () {
    return new Promise((resolve, reject) => {
      var element = document.createElement('script');
      element.async = true;
      // element.src = src;
      element.textContent = `var OUTPUT = (function () { ${script} })();`
      element.addEventListener('load', resolve(OUTPUT));
      element.addEventListener('error', () => reject('Error loading script.'));
      element.addEventListener('abort', () => reject('Script loading aborted.'));
      (document.head || document.documentElement).appendChild(injection);
    });
  }
  inject(script)
    .then(result => {
      console.warn('inject(script) result:', result)
      const event = document.createEvent('CustomEvent')
      event.initCustomEvent('INJECT_SCRIPT', true, true, result)
      window.dispatchEvent(event)
    })
    .then(() => {
      console.log('TODO: removal of tag via promise')
      // injection.remove()
    })
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('==SECURITY EXTENSION REQUEST==\n', request)
  const { type, body } = request || {}
  const { id } = sender || {}
  let response
  try {
    switch (type) {
      case 'script':
        // response = eval(`(function() { ${body} })();`)
        console.log('INJECTING')
        window.addEventListener('INJECT_SCRIPT', e => {
          console.warn('SCRIPT INJECTED', e)
          sendResponse({ success: true, response: e.detail })
        })
        INJECT_SCRIPT(body)
        // console.log('RESULTS IN CONTENT.SCRIPT', response)
        // sendResponse({ success: true, response })
        break
      case 'import':
        response = 'Import a package script placeholder'
        sendResponse({ success: true, response })
        break
      // default:
      //   response = 'Error: Unknown command'
      //   sendResponse({ success: false, response })
    }
  } catch (err) {
    response = { 'ERROR': err.message }
    sendResponse({ success: false, response })
  }
})

//  Resume sandbox testing for this:
/*
function INJECT_SCRIPT (script) {
  //  Create a script element on the target dom with a self executing function
  //  Add an event listener that returns the result. Remove the evidence.
  const scr = document.createElement('script')
  scr.textContent = `(function () {
    const result = (function () { ${script} })();
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('INJECT_SCRIPT', true, true, result);
    window.dispatchEvent(event);
  })();`;
  (document.head || document.documentElement).appendChild(scr)
  scr.parentNode.removeChild(scr)
}

//  Listen for the response
window.addEventListener('INJECT_SCRIPT', e => {
  const response = e.detail
  console.log('RESPONSE', response)
})

//  TEST
INJECT_SCRIPT('return 9001;')
*/

/*
var actualCode = `
var someFixedRandomValue = ${Math.random()};
console.warn(someFixedRandomValue);
`;

var script = document.createElement('script');
script.textContent = actualCode;
(document.head||document.documentElement).appendChild(script);
script.remove();
*/
